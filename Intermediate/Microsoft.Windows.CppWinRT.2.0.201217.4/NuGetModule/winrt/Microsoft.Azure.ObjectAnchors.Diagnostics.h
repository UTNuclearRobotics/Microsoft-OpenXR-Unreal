// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.201217.4

#ifndef WINRT_Microsoft_Azure_ObjectAnchors_Diagnostics_H
#define WINRT_Microsoft_Azure_ObjectAnchors_Diagnostics_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.201217.4"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.201217.4"
#include "winrt/Microsoft.Azure.ObjectAnchors.h"
#include "winrt/impl/Microsoft.Azure.ObjectAnchors.2.h"
#include "winrt/impl/Microsoft.Azure.ObjectAnchors.SpatialGraph.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Numerics.2.h"
#include "winrt/impl/Microsoft.Azure.ObjectAnchors.Diagnostics.2.h"
namespace winrt::impl
{
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_ObjectAnchors_Diagnostics_IObjectDiagnosticsSession<D>::ReportActualInstanceLocation(Microsoft::Azure::ObjectAnchors::ObjectInstance const& instance, Microsoft::Azure::ObjectAnchors::SpatialGraph::SpatialGraphCoordinateSystem const& coordinateSystem, Windows::Foundation::Numerics::float3 const& position, Windows::Foundation::Numerics::quaternion const& orientation) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSession)->ReportActualInstanceLocation(*(void**)(&instance), impl::bind_in(coordinateSystem), impl::bind_in(position), impl::bind_in(orientation)));
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncAction) consume_Microsoft_Azure_ObjectAnchors_Diagnostics_IObjectDiagnosticsSession<D>::CloseAsync(param::hstring const& diagnosticsFilePath) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSession)->CloseAsync(*(void**)(&diagnosticsFilePath), &operation));
        return Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::ObjectAnchors::Diagnostics::ObjectDiagnosticsSession) consume_Microsoft_Azure_ObjectAnchors_Diagnostics_IObjectDiagnosticsSessionFactory<D>::CreateInstance(Microsoft::Azure::ObjectAnchors::ObjectObserver const& observer, uint32_t maxSessionSizeInMegaBytes) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSessionFactory)->CreateInstance(*(void**)(&observer), maxSessionSizeInMegaBytes, &value));
        return Microsoft::Azure::ObjectAnchors::Diagnostics::ObjectDiagnosticsSession{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncOperation<Microsoft::Azure::ObjectAnchors::Diagnostics::ObjectDiagnosticsUploadStatus>) consume_Microsoft_Azure_ObjectAnchors_Diagnostics_IObjectDiagnosticsSessionStatics<D>::UploadDiagnosticsAsync(param::hstring const& diagnosticsFilePath, Microsoft::Azure::ObjectAnchors::ObjectAnchorsSession const& objectAnchorsSession) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSessionStatics)->UploadDiagnosticsAsync(*(void**)(&diagnosticsFilePath), *(void**)(&objectAnchorsSession), &operation));
        return Windows::Foundation::IAsyncOperation<Microsoft::Azure::ObjectAnchors::Diagnostics::ObjectDiagnosticsUploadStatus>{ operation, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSession> : produce_base<D, Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSession>
    {
        int32_t __stdcall ReportActualInstanceLocation(void* instance, struct struct_Microsoft_Azure_ObjectAnchors_SpatialGraph_SpatialGraphCoordinateSystem coordinateSystem, Windows::Foundation::Numerics::float3 position, Windows::Foundation::Numerics::quaternion orientation) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ReportActualInstanceLocation(*reinterpret_cast<Microsoft::Azure::ObjectAnchors::ObjectInstance const*>(&instance), *reinterpret_cast<Microsoft::Azure::ObjectAnchors::SpatialGraph::SpatialGraphCoordinateSystem const*>(&coordinateSystem), *reinterpret_cast<Windows::Foundation::Numerics::float3 const*>(&position), *reinterpret_cast<Windows::Foundation::Numerics::quaternion const*>(&orientation));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CloseAsync(void* diagnosticsFilePath, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().CloseAsync(*reinterpret_cast<hstring const*>(&diagnosticsFilePath)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSessionFactory> : produce_base<D, Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSessionFactory>
    {
        int32_t __stdcall CreateInstance(void* observer, uint32_t maxSessionSizeInMegaBytes, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::ObjectAnchors::Diagnostics::ObjectDiagnosticsSession>(this->shim().CreateInstance(*reinterpret_cast<Microsoft::Azure::ObjectAnchors::ObjectObserver const*>(&observer), maxSessionSizeInMegaBytes));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSessionStatics> : produce_base<D, Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSessionStatics>
    {
        int32_t __stdcall UploadDiagnosticsAsync(void* diagnosticsFilePath, void* objectAnchorsSession, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<Microsoft::Azure::ObjectAnchors::Diagnostics::ObjectDiagnosticsUploadStatus>>(this->shim().UploadDiagnosticsAsync(*reinterpret_cast<hstring const*>(&diagnosticsFilePath), *reinterpret_cast<Microsoft::Azure::ObjectAnchors::ObjectAnchorsSession const*>(&objectAnchorsSession)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Azure::ObjectAnchors::Diagnostics
{
    inline ObjectDiagnosticsSession::ObjectDiagnosticsSession(Microsoft::Azure::ObjectAnchors::ObjectObserver const& observer, uint32_t maxSessionSizeInMegaBytes) :
        ObjectDiagnosticsSession(impl::call_factory<ObjectDiagnosticsSession, IObjectDiagnosticsSessionFactory>([&](IObjectDiagnosticsSessionFactory const& f) { return f.CreateInstance(observer, maxSessionSizeInMegaBytes); }))
    {
    }
    inline auto ObjectDiagnosticsSession::UploadDiagnosticsAsync(param::hstring const& diagnosticsFilePath, Microsoft::Azure::ObjectAnchors::ObjectAnchorsSession const& objectAnchorsSession)
    {
        return impl::call_factory<ObjectDiagnosticsSession, IObjectDiagnosticsSessionStatics>([&](IObjectDiagnosticsSessionStatics const& f) { return f.UploadDiagnosticsAsync(diagnosticsFilePath, objectAnchorsSession); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSessionFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::ObjectAnchors::Diagnostics::IObjectDiagnosticsSessionStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::ObjectAnchors::Diagnostics::ObjectDiagnosticsSession> : winrt::impl::hash_base {};
#endif
}
#endif
